/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/files": {
    /**
     * List all files
     * @description Get a list of all uploaded files
     */
    get: operations["listFiles"];
    /**
     * Upload a file
     * @description Upload a file to the storage system (MinIO). Supports various file formats including PDF, DOCX, TXT, CSV, etc.
     */
    post: operations["uploadFile"];
  };
  "/files/{fileId}": {
    /**
     * Get file details
     * @description Get details of a specific file
     */
    get: operations["getFile"];
    /**
     * Delete a file
     * @description Delete a specific file from storage
     */
    delete: operations["deleteFile"];
  };
  "/datasets": {
    /**
     * List all datasets
     * @description Get a list of all datasets
     */
    get: operations["listDatasets"];
    /**
     * Create a dataset
     * @description Create a new dataset by grouping files
     */
    post: operations["createDataset"];
  };
  "/datasets/{datasetId}": {
    /**
     * Get dataset details
     * @description Get details of a specific dataset
     */
    get: operations["getDataset"];
    /**
     * Update a dataset
     * @description Update a specific dataset
     */
    put: operations["updateDataset"];
    /**
     * Delete a dataset
     * @description Delete a specific dataset
     */
    delete: operations["deleteDataset"];
  };
  "/knowledge-bases": {
    /**
     * List all knowledge bases
     * @description Get a list of all knowledge bases
     */
    get: operations["listKnowledgeBases"];
    /**
     * Create a knowledge base
     * @description Create a new knowledge base by grouping datasets
     */
    post: operations["createKnowledgeBase"];
  };
  "/knowledge-bases/{knowledgeBaseId}": {
    /**
     * Get knowledge base details
     * @description Get details of a specific knowledge base
     */
    get: operations["getKnowledgeBase"];
    /**
     * Update a knowledge base
     * @description Update a specific knowledge base
     */
    put: operations["updateKnowledgeBase"];
    /**
     * Delete a knowledge base
     * @description Delete a specific knowledge base
     */
    delete: operations["deleteKnowledgeBase"];
  };
  "/models/local": {
    /**
     * Pull a local model using Ollama
     * @description Pull a model from Ollama and register it in the system
     */
    post: operations["pullLocalModel"];
  };
  "/models/provider": {
    /**
     * Register a provider model
     * @description Register a model from providers like OpenAI or Anthropic
     */
    post: operations["registerProviderModel"];
  };
  "/models": {
    /**
     * List all models
     * @description Get a list of all registered models
     */
    get: operations["listModels"];
  };
  "/models/{modelId}": {
    /**
     * Get model details
     * @description Get details of a specific model
     */
    get: operations["getModel"];
  };
  "/model-catalog": {
    /**
     * Get model catalog
     * @description Get a list of available models in the catalog
     */
    get: operations["getModelCatalog"];
  };
  "/inference": {
    /**
     * Run inference
     * @description Run inference using a specific model
     */
    post: operations["runInference"];
  };
  "/fine-tune": {
    /**
     * List fine-tuning jobs
     * @description Get a list of all fine-tuning jobs
     */
    get: operations["listFineTuneJobs"];
    /**
     * Start fine-tuning
     * @description Start fine-tuning a model using a dataset
     */
    post: operations["startFineTune"];
  };
  "/fine-tune/{jobId}": {
    /**
     * Get fine-tuning job details
     * @description Get details of a specific fine-tuning job
     */
    get: operations["getFineTuneJob"];
    /**
     * Cancel fine-tuning job
     * @description Cancel a specific fine-tuning job
     */
    delete: operations["cancelFineTuneJob"];
  };
  "/models/custom": {
    /**
     * Create a custom model
     * @description Create a model from scratch with custom parameters
     */
    post: operations["createCustomModel"];
  };
  "/chunks": {
    /**
     * List chunks
     * @description Get a list of chunks
     */
    get: operations["listChunks"];
    /**
     * Chunk files
     * @description Chunk files into manageable pieces for vectorization
     */
    post: operations["chunkFiles"];
  };
  "/chunks/{chunkId}": {
    /**
     * Get chunk details
     * @description Get details of a specific chunk
     */
    get: operations["getChunk"];
  };
  "/embeddings": {
    /**
     * List embeddings
     * @description Get a list of embeddings
     */
    get: operations["listEmbeddings"];
    /**
     * Generate embeddings
     * @description Generate embeddings for chunks using a specific model
     */
    post: operations["generateEmbeddings"];
  };
  "/embeddings/{embeddingId}": {
    /**
     * Get embedding details
     * @description Get details of a specific embedding
     */
    get: operations["getEmbedding"];
  };
  "/vector-store": {
    /**
     * Store embeddings in vector store
     * @description Store generated embeddings in the vector store
     */
    post: operations["storeEmbeddings"];
  };
  "/vector-store/search": {
    /**
     * Search vector store
     * @description Search the vector store using a query embedding
     */
    post: operations["searchVectorStore"];
  };
  "/vector-store/collections": {
    /**
     * List vector store collections
     * @description Get a list of all collections in the vector store
     */
    get: operations["listVectorStoreCollections"];
  };
  "/vector-store/collections/{collectionName}": {
    /**
     * Delete vector store collection
     * @description Delete a specific collection from the vector store
     */
    delete: operations["deleteVectorStoreCollection"];
  };
  "/health": {
    /**
     * Health check
     * @description Check the health status of the API
     */
    get: operations["healthCheck"];
  };
  "/status": {
    /**
     * System status
     * @description Get detailed system status information
     */
    get: operations["systemStatus"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    Error: {
      /** @description Error code */
      code: string;
      /** @description Error message */
      message: string;
      /** @description Additional error details */
      details?: Record<string, never>;
    };
    ValidationError: {
      /**
       * @example Validation failed
       * @enum {string}
       */
      code: "VALIDATION_ERROR";
      /** @example Validation failed */
      message: string;
      errors: {
          /** @description The field that failed validation */
          field: string;
          /** @description Description of the validation error */
          message: string;
        }[];
    };
    File: {
      /** Format: uuid */
      id?: string;
      filename?: string;
      mimeType?: string;
      /** Format: int64 */
      size?: number;
      /** Format: date-time */
      createdAt?: string;
      /** @description Location in MinIO storage */
      storageLocation?: string;
      metadata?: {
        [key: string]: unknown;
      };
    };
    Dataset: {
      /** Format: uuid */
      id?: string;
      name?: string;
      description?: string;
      files?: components["schemas"]["File"][];
      /** Format: date-time */
      createdAt?: string;
      /** Format: date-time */
      updatedAt?: string;
    };
    KnowledgeBase: {
      /** Format: uuid */
      id?: string;
      name?: string;
      description?: string;
      datasets?: components["schemas"]["Dataset"][];
      /** Format: date-time */
      createdAt?: string;
      /** Format: date-time */
      updatedAt?: string;
    };
    Model: {
      /** Format: uuid */
      id?: string;
      name?: string;
      /** @enum {string} */
      type?: "embedding" | "llm";
      /** @enum {string} */
      provider?: "local" | "openai" | "anthropic" | "custom";
      /** @description Source of the model (for local models: ollama, for remote: API endpoint) */
      source?: string;
      parameters?: {
        [key: string]: unknown;
      };
      /** Format: date-time */
      createdAt?: string;
      /** Format: date-time */
      updatedAt?: string;
    };
    ModelCatalogEntry: {
      /** Format: uuid */
      id?: string;
      name?: string;
      description?: string;
      /** @enum {string} */
      type?: "embedding" | "llm";
      provider?: string;
      capabilities?: string[];
      parameters?: {
        [key: string]: unknown;
      };
    };
    Chunk: {
      /** Format: uuid */
      id?: string;
      content?: string;
      metadata?: {
        [key: string]: unknown;
      };
      /** Format: uuid */
      fileId?: string;
      startIndex?: number;
      endIndex?: number;
    };
    Embedding: {
      /** Format: uuid */
      id?: string;
      /** Format: uuid */
      chunkId?: string;
      /** Format: uuid */
      modelId?: string;
      vector?: number[];
      dimensions?: number;
      /** Format: date-time */
      createdAt?: string;
    };
    InferenceRequest: {
      /** Format: uuid */
      modelId: string;
      prompt: string;
      parameters?: {
        [key: string]: unknown;
      };
      /**
       * Format: uuid
       * @description Optional knowledge base to use for context
       */
      knowledgeBaseId?: string;
    };
    InferenceResponse: {
      /** Format: uuid */
      id?: string;
      response?: string;
      /** Format: uuid */
      modelId?: string;
      promptTokens?: number;
      completionTokens?: number;
      totalTokens?: number;
      /** Format: float */
      latency?: number;
      metadata?: {
        [key: string]: unknown;
      };
      /** Format: date-time */
      createdAt?: string;
    };
    FineTuneRequest: {
      /** Format: uuid */
      baseModelId: string;
      /** Format: uuid */
      datasetId: string;
      name: string;
      hyperparameters?: {
        [key: string]: unknown;
      };
    };
    FineTuneJob: {
      /** Format: uuid */
      id?: string;
      /** Format: uuid */
      baseModelId?: string;
      /** Format: uuid */
      datasetId?: string;
      name?: string;
      /** @enum {string} */
      status?: "pending" | "running" | "completed" | "failed";
      /** Format: float */
      progress?: number;
      /** Format: date-time */
      createdAt?: string;
      /** Format: date-time */
      completedAt?: string;
      /** Format: uuid */
      resultModelId?: string;
    };
    ChunkingConfig: {
      /** @enum {string} */
      strategy?: "fixed_size" | "semantic" | "hybrid";
      /** @description For fixed_size strategy, chunk size in tokens */
      size?: number;
      /** @description Overlap between chunks in tokens */
      overlap?: number;
      parameters?: {
        [key: string]: unknown;
      };
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * List all files
   * @description Get a list of all uploaded files
   */
  listFiles: {
    parameters: {
      query?: {
        /** @description Page number for pagination */
        page?: number;
        /** @description Number of items per page */
        limit?: number;
        /** @description Filter by file type/mime type */
        type?: string;
      };
    };
    responses: {
      /** @description List of files */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["File"][];
            pagination?: {
              total?: number;
              pages?: number;
              page?: number;
              limit?: number;
            };
          };
        };
      };
      401: components["responses"]["Unauthorized"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Upload a file
   * @description Upload a file to the storage system (MinIO). Supports various file formats including PDF, DOCX, TXT, CSV, etc.
   */
  uploadFile: {
    requestBody: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
          metadata?: {
            [key: string]: unknown;
          };
        };
      };
    };
    responses: {
      /** @description File uploaded successfully */
      201: {
        content: {
          "application/json": components["schemas"]["File"];
        };
      };
      400: components["responses"]["BadRequest"];
      401: components["responses"]["Unauthorized"];
      /** @description File too large */
      413: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Get file details
   * @description Get details of a specific file
   */
  getFile: {
    parameters: {
      path: {
        /** @description ID of the file to retrieve */
        fileId: string;
      };
    };
    responses: {
      /** @description File details */
      200: {
        content: {
          "application/json": components["schemas"]["File"];
        };
      };
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Delete a file
   * @description Delete a specific file from storage
   */
  deleteFile: {
    parameters: {
      path: {
        /** @description ID of the file to delete */
        fileId: string;
      };
    };
    responses: {
      /** @description File deleted successfully */
      204: {
        content: never;
      };
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * List all datasets
   * @description Get a list of all datasets
   */
  listDatasets: {
    parameters: {
      query?: {
        /** @description Page number for pagination */
        page?: number;
        /** @description Number of items per page */
        limit?: number;
      };
    };
    responses: {
      /** @description List of datasets */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["Dataset"][];
            pagination?: {
              total?: number;
              pages?: number;
              page?: number;
              limit?: number;
            };
          };
        };
      };
      401: components["responses"]["Unauthorized"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Create a dataset
   * @description Create a new dataset by grouping files
   */
  createDataset: {
    requestBody: {
      content: {
        "application/json": {
          name: string;
          description?: string;
          /** @description IDs of files to include in this dataset */
          fileIds: string[];
        };
      };
    };
    responses: {
      /** @description Dataset created successfully */
      201: {
        content: {
          "application/json": components["schemas"]["Dataset"];
        };
      };
      400: components["responses"]["ValidationError"];
      401: components["responses"]["Unauthorized"];
      /** @description One or more files not found */
      404: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Get dataset details
   * @description Get details of a specific dataset
   */
  getDataset: {
    parameters: {
      path: {
        /** @description ID of the dataset to retrieve */
        datasetId: string;
      };
    };
    responses: {
      /** @description Dataset details */
      200: {
        content: {
          "application/json": components["schemas"]["Dataset"];
        };
      };
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Update a dataset
   * @description Update a specific dataset
   */
  updateDataset: {
    parameters: {
      path: {
        /** @description ID of the dataset to update */
        datasetId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          name?: string;
          description?: string;
          /** @description IDs of files to include in this dataset */
          fileIds?: string[];
        };
      };
    };
    responses: {
      /** @description Dataset updated successfully */
      200: {
        content: {
          "application/json": components["schemas"]["Dataset"];
        };
      };
      400: components["responses"]["ValidationError"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Delete a dataset
   * @description Delete a specific dataset
   */
  deleteDataset: {
    parameters: {
      path: {
        /** @description ID of the dataset to delete */
        datasetId: string;
      };
    };
    responses: {
      /** @description Dataset deleted successfully */
      204: {
        content: never;
      };
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * List all knowledge bases
   * @description Get a list of all knowledge bases
   */
  listKnowledgeBases: {
    parameters: {
      query?: {
        /** @description Page number for pagination */
        page?: number;
        /** @description Number of items per page */
        limit?: number;
      };
    };
    responses: {
      /** @description List of knowledge bases */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["KnowledgeBase"][];
            pagination?: {
              total?: number;
              pages?: number;
              page?: number;
              limit?: number;
            };
          };
        };
      };
      401: components["responses"]["Unauthorized"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Create a knowledge base
   * @description Create a new knowledge base by grouping datasets
   */
  createKnowledgeBase: {
    requestBody: {
      content: {
        "application/json": {
          name: string;
          description?: string;
          /** @description IDs of datasets to include in this knowledge base */
          datasetIds: string[];
        };
      };
    };
    responses: {
      /** @description Knowledge base created successfully */
      201: {
        content: {
          "application/json": components["schemas"]["KnowledgeBase"];
        };
      };
      400: components["responses"]["ValidationError"];
      401: components["responses"]["Unauthorized"];
      /** @description One or more datasets not found */
      404: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Get knowledge base details
   * @description Get details of a specific knowledge base
   */
  getKnowledgeBase: {
    parameters: {
      path: {
        /** @description ID of the knowledge base to retrieve */
        knowledgeBaseId: string;
      };
    };
    responses: {
      /** @description Knowledge base details */
      200: {
        content: {
          "application/json": components["schemas"]["KnowledgeBase"];
        };
      };
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Update a knowledge base
   * @description Update a specific knowledge base
   */
  updateKnowledgeBase: {
    parameters: {
      path: {
        /** @description ID of the knowledge base to update */
        knowledgeBaseId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": {
          name?: string;
          description?: string;
          /** @description IDs of datasets to include in this knowledge base */
          datasetIds?: string[];
        };
      };
    };
    responses: {
      /** @description Knowledge base updated successfully */
      200: {
        content: {
          "application/json": components["schemas"]["KnowledgeBase"];
        };
      };
      400: components["responses"]["ValidationError"];
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Delete a knowledge base
   * @description Delete a specific knowledge base
   */
  deleteKnowledgeBase: {
    parameters: {
      path: {
        /** @description ID of the knowledge base to delete */
        knowledgeBaseId: string;
      };
    };
    responses: {
      /** @description Knowledge base deleted successfully */
      204: {
        content: never;
      };
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Pull a local model using Ollama
   * @description Pull a model from Ollama and register it in the system
   */
  pullLocalModel: {
    requestBody: {
      content: {
        "application/json": {
          /** @description Name to register the model as */
          name: string;
          /**
           * @description Type of model
           * @enum {string}
           */
          type: "embedding" | "llm";
          /** @description Name of the model in Ollama */
          ollamaName: string;
          /** @description Model-specific parameters */
          parameters?: {
            [key: string]: unknown;
          };
        };
      };
    };
    responses: {
      /** @description Model pull initiated */
      202: {
        content: {
          "application/json": components["schemas"]["Model"] & ({
            /** @enum {string} */
            status?: "pending" | "downloading" | "ready" | "failed";
            /** Format: float */
            progress?: number;
          });
        };
      };
      400: components["responses"]["ValidationError"];
      401: components["responses"]["Unauthorized"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Register a provider model
   * @description Register a model from providers like OpenAI or Anthropic
   */
  registerProviderModel: {
    requestBody: {
      content: {
        "application/json": {
          /** @description Name to register the model as */
          name: string;
          /**
           * @description Type of model
           * @enum {string}
           */
          type: "embedding" | "llm";
          /**
           * @description Provider of the model
           * @enum {string}
           */
          provider: "openai" | "anthropic";
          /** @description ID of the model on the provider's platform */
          modelId: string;
          /** @description Model-specific parameters */
          parameters?: {
            [key: string]: unknown;
          };
          /** @description API key for the provider (if not set in environment) */
          apiKey?: string;
        };
      };
    };
    responses: {
      /** @description Provider model registered */
      201: {
        content: {
          "application/json": components["schemas"]["Model"];
        };
      };
      400: components["responses"]["ValidationError"];
      401: components["responses"]["Unauthorized"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * List all models
   * @description Get a list of all registered models
   */
  listModels: {
    parameters: {
      query?: {
        /** @description Filter by model type */
        type?: "embedding" | "llm";
        /** @description Filter by provider */
        provider?: "local" | "openai" | "anthropic" | "custom";
        /** @description Page number for pagination */
        page?: number;
        /** @description Number of items per page */
        limit?: number;
      };
    };
    responses: {
      /** @description List of models */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["Model"][];
            pagination?: {
              total?: number;
              pages?: number;
              page?: number;
              limit?: number;
            };
          };
        };
      };
      401: components["responses"]["Unauthorized"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Get model details
   * @description Get details of a specific model
   */
  getModel: {
    parameters: {
      path: {
        /** @description ID of the model to retrieve */
        modelId: string;
      };
    };
    responses: {
      /** @description Model details */
      200: {
        content: {
          "application/json": components["schemas"]["Model"];
        };
      };
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Get model catalog
   * @description Get a list of available models in the catalog
   */
  getModelCatalog: {
    parameters: {
      query?: {
        /** @description Filter by model type */
        type?: "embedding" | "llm";
        /** @description Filter by provider */
        provider?: string;
        /** @description Page number for pagination */
        page?: number;
        /** @description Number of items per page */
        limit?: number;
      };
    };
    responses: {
      /** @description Model catalog */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["ModelCatalogEntry"][];
            pagination?: {
              total?: number;
              pages?: number;
              page?: number;
              limit?: number;
            };
          };
        };
      };
      401: components["responses"]["Unauthorized"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Run inference
   * @description Run inference using a specific model
   */
  runInference: {
    requestBody: {
      content: {
        /**
         * @example {
         *   "modelId": "550e8400-e29b-41d4-a716-446655440000",
         *   "prompt": "What is the capital of France?",
         *   "parameters": {
         *     "temperature": 0.7,
         *     "max_tokens": 100
         *   },
         *   "knowledgeBaseId": "550e8400-e29b-41d4-a716-446655440001"
         * }
         */
        "application/json": components["schemas"]["InferenceRequest"];
      };
    };
    responses: {
      /** @description Inference result */
      200: {
        content: {
          "application/json": components["schemas"]["InferenceResponse"];
        };
      };
      400: components["responses"]["ValidationError"];
      401: components["responses"]["Unauthorized"];
      /** @description Model not found */
      404: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * List fine-tuning jobs
   * @description Get a list of all fine-tuning jobs
   */
  listFineTuneJobs: {
    parameters: {
      query?: {
        /** @description Filter by job status */
        status?: "pending" | "running" | "completed" | "failed";
        /** @description Filter by base model ID */
        modelId?: string;
        /** @description Page number for pagination */
        page?: number;
        /** @description Number of items per page */
        limit?: number;
      };
    };
    responses: {
      /** @description List of fine-tuning jobs */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["FineTuneJob"][];
            pagination?: {
              total?: number;
              pages?: number;
              page?: number;
              limit?: number;
            };
          };
        };
      };
      401: components["responses"]["Unauthorized"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Start fine-tuning
   * @description Start fine-tuning a model using a dataset
   */
  startFineTune: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["FineTuneRequest"];
      };
    };
    responses: {
      /** @description Fine-tuning job created */
      202: {
        content: {
          "application/json": components["schemas"]["FineTuneJob"];
        };
      };
      400: components["responses"]["ValidationError"];
      401: components["responses"]["Unauthorized"];
      /** @description Model or dataset not found */
      404: {
        content: {
          "application/json": unknown;
        };
      };
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Get fine-tuning job details
   * @description Get details of a specific fine-tuning job
   */
  getFineTuneJob: {
    parameters: {
      path: {
        /** @description ID of the fine-tuning job to retrieve */
        jobId: string;
      };
    };
    responses: {
      /** @description Fine-tuning job details */
      200: {
        content: {
          "application/json": components["schemas"]["FineTuneJob"];
        };
      };
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Cancel fine-tuning job
   * @description Cancel a specific fine-tuning job
   */
  cancelFineTuneJob: {
    parameters: {
      path: {
        /** @description ID of the fine-tuning job to cancel */
        jobId: string;
      };
    };
    responses: {
      /** @description Fine-tuning job cancelled successfully */
      204: {
        content: never;
      };
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      /** @description Cannot cancel completed job */
      409: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Create a custom model
   * @description Create a model from scratch with custom parameters
   */
  createCustomModel: {
    requestBody: {
      content: {
        "application/json": {
          /** @description Name of the custom model */
          name: string;
          /**
           * @description Type of model
           * @enum {string}
           */
          type: "embedding" | "llm";
          /** @description Architecture of the model */
          architecture: string;
          /** @description Model-specific parameters */
          parameters?: {
            [key: string]: unknown;
          };
          /**
           * Format: binary
           * @description Initial weights for the model (optional)
           */
          initial_weights?: string;
        };
      };
    };
    responses: {
      /** @description Custom model creation initiated */
      202: {
        content: {
          "application/json": components["schemas"]["Model"] & ({
            /** @enum {string} */
            status?: "pending" | "initializing" | "ready" | "failed";
          });
        };
      };
      400: components["responses"]["ValidationError"];
      401: components["responses"]["Unauthorized"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * List chunks
   * @description Get a list of chunks
   */
  listChunks: {
    parameters: {
      query?: {
        /** @description Filter by file ID */
        fileId?: string;
        /** @description Page number for pagination */
        page?: number;
        /** @description Number of items per page */
        limit?: number;
      };
    };
    responses: {
      /** @description List of chunks */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["Chunk"][];
            pagination?: {
              total?: number;
              pages?: number;
              page?: number;
              limit?: number;
            };
          };
        };
      };
      401: components["responses"]["Unauthorized"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Chunk files
   * @description Chunk files into manageable pieces for vectorization
   */
  chunkFiles: {
    requestBody: {
      content: {
        "application/json": {
          /** @description IDs of files to chunk */
          fileIds: string[];
          config?: components["schemas"]["ChunkingConfig"];
        };
      };
    };
    responses: {
      /** @description Chunking initiated */
      202: {
        content: {
          "application/json": {
            /** Format: uuid */
            jobId?: string;
            /** @enum {string} */
            status?: "pending" | "processing" | "completed" | "failed";
            fileIds?: string[];
          };
        };
      };
      400: components["responses"]["ValidationError"];
      401: components["responses"]["Unauthorized"];
      /** @description One or more files not found */
      404: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Get chunk details
   * @description Get details of a specific chunk
   */
  getChunk: {
    parameters: {
      path: {
        /** @description ID of the chunk to retrieve */
        chunkId: string;
      };
    };
    responses: {
      /** @description Chunk details */
      200: {
        content: {
          "application/json": components["schemas"]["Chunk"];
        };
      };
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * List embeddings
   * @description Get a list of embeddings
   */
  listEmbeddings: {
    parameters: {
      query?: {
        /** @description Filter by chunk ID */
        chunkId?: string;
        /** @description Filter by model ID */
        modelId?: string;
        /** @description Page number for pagination */
        page?: number;
        /** @description Number of items per page */
        limit?: number;
      };
    };
    responses: {
      /** @description List of embeddings */
      200: {
        content: {
          "application/json": {
            data?: (components["schemas"]["Embedding"] & {
                /** @description Base64 encoded vector (abbreviated for pagination) */
                vector?: string;
              })[];
            pagination?: {
              total?: number;
              pages?: number;
              page?: number;
              limit?: number;
            };
          };
        };
      };
      401: components["responses"]["Unauthorized"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Generate embeddings
   * @description Generate embeddings for chunks using a specific model
   */
  generateEmbeddings: {
    requestBody: {
      content: {
        "application/json": {
          /** @description IDs of chunks to generate embeddings for */
          chunkIds: string[];
          /**
           * Format: uuid
           * @description ID of the embedding model to use
           */
          modelId: string;
        };
      };
    };
    responses: {
      /** @description Embedding generation initiated */
      202: {
        content: {
          "application/json": {
            /** Format: uuid */
            jobId?: string;
            /** @enum {string} */
            status?: "pending" | "processing" | "completed" | "failed";
            /** Format: float */
            progress?: number;
          };
        };
      };
      400: components["responses"]["ValidationError"];
      401: components["responses"]["Unauthorized"];
      /** @description Model or chunks not found */
      404: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Get embedding details
   * @description Get details of a specific embedding
   */
  getEmbedding: {
    parameters: {
      path: {
        /** @description ID of the embedding to retrieve */
        embeddingId: string;
      };
    };
    responses: {
      /** @description Embedding details */
      200: {
        content: {
          "application/json": components["schemas"]["Embedding"];
        };
      };
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Store embeddings in vector store
   * @description Store generated embeddings in the vector store
   */
  storeEmbeddings: {
    requestBody: {
      content: {
        "application/json": {
          /** @description IDs of embeddings to store */
          embeddingIds: string[];
          /** @description Name of the vector store collection (optional) */
          collection?: string;
        };
      };
    };
    responses: {
      /** @description Storing embeddings initiated */
      202: {
        content: {
          "application/json": {
            /** Format: uuid */
            jobId?: string;
            /** @enum {string} */
            status?: "pending" | "processing" | "completed" | "failed";
            /** Format: float */
            progress?: number;
          };
        };
      };
      400: components["responses"]["ValidationError"];
      401: components["responses"]["Unauthorized"];
      /** @description Embeddings not found */
      404: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Search vector store
   * @description Search the vector store using a query embedding
   */
  searchVectorStore: {
    requestBody: {
      content: {
        /**
         * @example {
         *   "query": "What is machine learning?",
         *   "modelId": "550e8400-e29b-41d4-a716-446655440000",
         *   "collection": "knowledge_base",
         *   "limit": 5,
         *   "threshold": 0.8
         * }
         */
        "application/json": {
          /** @description Text query to convert to embedding */
          query?: string;
          /**
           * Format: uuid
           * @description ID of the embedding model to use
           */
          modelId?: string;
          /** @description Direct embedding vector to search with */
          embeddingVector?: number[];
          /** @description Name of the vector store collection to search */
          collection?: string;
          /**
           * @description Maximum number of results to return
           * @default 10
           */
          limit?: number;
          /**
           * Format: float
           * @description Similarity threshold
           * @default 0.75
           */
          threshold?: number;
        };
      };
    };
    responses: {
      /** @description Search results */
      200: {
        content: {
          "application/json": {
            results?: {
                /** Format: uuid */
                embeddingId?: string;
                /** Format: uuid */
                chunkId?: string;
                content?: string;
                /** Format: float */
                similarity?: number;
                metadata?: {
                  [key: string]: unknown;
                };
              }[];
          };
        };
      };
      400: components["responses"]["ValidationError"];
      401: components["responses"]["Unauthorized"];
      /** @description Model not found */
      404: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * List vector store collections
   * @description Get a list of all collections in the vector store
   */
  listVectorStoreCollections: {
    responses: {
      /** @description List of collections */
      200: {
        content: {
          "application/json": {
            collections?: {
                name?: string;
                count?: number;
                dimensions?: number;
                /** Format: date-time */
                createdAt?: string;
              }[];
          };
        };
      };
      401: components["responses"]["Unauthorized"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Delete vector store collection
   * @description Delete a specific collection from the vector store
   */
  deleteVectorStoreCollection: {
    parameters: {
      path: {
        /** @description Name of the collection to delete */
        collectionName: string;
      };
    };
    responses: {
      /** @description Collection deleted successfully */
      204: {
        content: never;
      };
      401: components["responses"]["Unauthorized"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  /**
   * Health check
   * @description Check the health status of the API
   */
  healthCheck: {
    responses: {
      /** @description API is healthy */
      200: {
        content: {
          "application/json": {
            /** @example ok */
            status?: string;
            /** Format: date-time */
            timestamp?: string;
          };
        };
      };
      /** @description API is not healthy */
      500: {
        content: {
          "application/json": {
            /** @example error */
            status?: string;
            message?: string;
          };
        };
      };
    };
  };
  /**
   * System status
   * @description Get detailed system status information
   */
  systemStatus: {
    responses: {
      /** @description System status information */
      200: {
        content: {
          "application/json": {
            api?: {
              /** @enum {string} */
              status?: "healthy" | "degraded" | "unavailable";
              version?: string;
            };
            storage?: {
              /** @enum {string} */
              status?: "healthy" | "degraded" | "unavailable";
              /** Format: int64 */
              usedSpace?: number;
              /** Format: int64 */
              totalSpace?: number;
            };
            vectorStore?: {
              /** @enum {string} */
              status?: "healthy" | "degraded" | "unavailable";
              collections?: number;
            };
            modelServices?: {
              /** @enum {string} */
              status?: "healthy" | "degraded" | "unavailable";
              activeModels?: number;
            };
          };
        };
      };
      401: components["responses"]["Unauthorized"];
      500: components["responses"]["InternalServerError"];
    };
  };
}
